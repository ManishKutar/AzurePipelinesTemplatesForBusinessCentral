parameters:
- name: bcVersion
  type: string
- name: alLanguageExtensionFileName
  type: string
  default: ''
- name: rulesetFileName
  type: string
  default: ''
- name: enableCodeCop
  type: string
  default: true
- name: enableAppSourceCop
  type: string
  default: true
- name: enablePerTenantExtensionCop
  type: string
  default: true
- name: enableUICop
  type: string
  default: true

- name: organizationName
  type: string
  default: ''
- name: mainAppFolder
  type: string
  default: MainApp
- name: testAppFolder
  type: string
  default: TestApp
- name: masterBranch
  type: string
  default: WIP
- name: appVersionSelection
  type: string
  default: manifest
  values:
  - manifest
  - dockerImageMajorMinorAndManifestMajorMinor
  - dockerImageMajorMinorAndManifestBuildRevision
  - manual
- name: appVersion
  type: string
  default: '0.0.0.0'
- name: manifestVersionMismatchAction
  type: string
  default: error
  values:
  - error
  - warning
  - none
  
- name: appReleaseVersionSelection
  type: string
  default: manifestBuildRevision
  values:
  - manifestMajorMinor
  - manifestBuildRevision
  - manual
- name: appReleaseVersion
  type: string
  default: ''
    
- name: dockerMemory
  type: string
  default: 4g
- name: dockerIsolation
  type: string
  default: hyperv
  values: 
  - hyperv
  - process

- name: failCompilationOnWarnings
  type: boolean
  default: true
 
- name: testType
  type: string
  default: none
  values:
  - none
  - sameApp
  - testApp
- name: testFilter
  type: string
  default: ''
- name: installALTestTool   #bc14 ir žemesnėm nurodom false
  type: boolean
  default: true
- name: failedTestAction
  type: string
  default: Warning
  values:
  - Warning
  - Error
  - Ignore
  
- name: eInvoice
  type: boolean
  default: false
- name: S4LESSEE
  type: boolean
  default: false
- name: latestIntegrationCoreAppPath
  type: string
  default: ''
- name: latestSofteraBalticLoggingAppPath
  type: string
  default: ''
- name: latestCoreAppPath 
  type: string
  default: ''
- name: latestHRAppPath 
  type: string
  default: ''
- name: latestTimeScheduleAppPath 
  type: string
  default: ''
- name: latestTimeEmployeeTimeAppPath 
  type: string
  default: ''
- name: latestSalaryAppPath 
  type: string
  default: ''
- name: latestLBCAlnaCoreAppPath
  type: string
  default: ''

stages:
- stage: Main
  displayName: Main
  jobs:
  - job: Main
    condition: or(startsWith(variables['Build.SourceBranchName'], variables['MasterBranch']), startsWith(variables['Build.SourceBranchName'], variables['merge']), eq(variables['IsReleasePRCommit'], 'True'))
    variables:
    - name: BcArtifactType
      value: ''
    - name: BcArtifactVersion
      value: ''
    - name: BcArtifactCountry
      value: ''
    - name: BcArtifactStorageAccount
      value: ''
    - name: BcArtifactSasToken
      value: ''
    - name: AppVersion
      value: ''
    - name: AppReleaseVersion
      value: ''
    - name: MainAppFolder
      value: ${{ parameters.mainAppFolder }}
    - name: TestAppFolder
      value: ${{ parameters.testAppFolder }}
    - name: OrganizationName
      value: ${{ parameters.organizationName }}
      
    - name: DockerMemory
      value: ${{ parameters.dockerMemory }}
      
    - name: IsPullRequest
      value: $[ ne(variables['System.PullRequest.PullRequestId'], '') ]
    - name: MasterBranch
      value: ${{ parameters.masterBranch }}
    - name: IsReleasePRCommit
      value: $[ startsWith(variables['Build.SourceVersionMessage'], 'Merge WIP to Release-') ]
    - name: BcApplicationVersion
      value: ''
    steps:
    - powershell: |
        $ExitCode = 0
        $FreeDiskSpace = Get-PSDrive -Name C | Select-Object -ExpandProperty Free 
        if ($FreeDiskSpace -lt 10gb) {
            Write-Host -Object '##[error]There is no free disk space left. There must be atleast 10 GB.'
            $ExitCode = 1
        }
        Add-Type -AssemblyName Microsoft.VisualBasic
        $ComputerInfo = [Microsoft.VisualBasic.Devices.ComputerInfo]::new()
        if ($ComputerInfo.AvailablePhysicalMemory -lt 4gb) {
            Write-Host -Object '##[error]There is no free memory space left. There must be atleast 4 GB.'
            $ExitCode = 1
        }
        exit($ExitCode)
      condition: always()
      displayName: Checking free disk and ram space
    
    - powershell: |
        Set-StrictMode -Version Latest
        Write-Host -Object "BC version given $env:BcVersion"

        $Pattern = '^(?<Type>OnPrem|Sandbox)\/(?<Version>Current|NextMinor|NextMajor|\d+(?:\.\d+){0,3})\/(?<Country>base|w1|[a-zA-Z]{2})$'
        if ($env:BcVersion -notmatch $Pattern) {
          Write-Host -Object 'BC version expected pattern ''<OnPrem|Sandbox>/<Current|NextMinor|NextMajor|Numeric version, eg 16.3>/<base or w1 or country>'' (case sensitive)'
          throw 'BC version doesn''t match pattern. '
        }

        Write-Host
        Write-Host -Object "Parsed artifact type:    $($Matches.Type)"
        Write-Host -Object "Parsed artifact version: $($Matches.Version)"
        Write-Host -Object "Parsed artifact country: $($Matches.Country)"

        $Type = $Matches.Type
        $Version = $Matches.Version
        $Country = $Matches.Country
        $StorageAccount = 'bcartifacts'
        $SasToken = ''
        switch ($Version) {
          'Current' {
            $Version = ''
            break
          }
          'NextMinor' {
            #TODO change version
            $Version = '17'
            $StorageAccount = 'bcinsider'
            $SasToken = $env:BcInsiderSasToken
            break
          }
          'NextMajor' {
            $Version = ''
            $StorageAccount = 'bcinsider'
            $SasToken = $env:BcInsiderSasToken
            break
          }
        }

        Write-Host
        Write-Host -Object "Artifact type:            $Type"
        Write-Host -Object "Artifact version:         $($Version -creplace '^$', $Matches.Version)"
        Write-Host -Object "Artifact country:         $Country"
        Write-Host -Object "Artifact storage account: $StorageAccount"

        Write-Host -Object "##vso[task.setvariable variable=BcArtifactType;]$Type"
        Write-Host -Object "##vso[task.setvariable variable=BcArtifactVersion;]$Version"
        Write-Host -Object "##vso[task.setvariable variable=BcArtifactCountry;]$Country"
        Write-Host -Object "##vso[task.setvariable variable=BcArtifactStorageAccount;]$StorageAccount"
        Write-Host -Object "##vso[task.setvariable variable=BcArtifactSasToken;isSecret=true]$SasToken"
      env: 
        BcVersion: ${{ parameters.bcVersion }}
        BcInsiderSasToken: $(BCSasToken)
      displayName: Select BC artifact version

    - checkout: self
      clean: true
        
    - task: DownloadSecureFile@1
      name: DownloadBCLicense
      inputs:
        secureFile: $(BCLicense.SecureFileName)
      displayName: Download BC license

    - task: DownloadSecureFile@1
      name: DownloadBCAppSigningCertificate
      inputs:
        secureFile: $(BCAppSigningCertificateSecureFileName)
      displayName: Download certificate for BC app signing

#     - task: PowerShell@2
#       displayName: 'Install BcContainerHelper'
#       inputs:
#         targetType: inline
#         script: 'Install-Module -Name BcContainerHelper -Force'

    - powershell: |
        #$BcApplicationVersion = Get-NAVApplication -ServerInstance bc | Select-Object -ExpandProperty ApplicationVersion
        $ArtifactUrl = Get-BcArtifactUrl -type $env:BcArtifactType -version $env:BcArtifactVersion -country $env:BcArtifactCountry -sasToken $env:BcArtifactSasToken -storageAccount $env:BcArtifactStorageAccount
        Write-Host -Object "##vso[task.setvariable variable=ArtifactUrl;]$ArtifactUrl"
        $parts = $ArtifactUrl.Split('/')
        $BcApplicationVersion = $parts[4]
        Write-Host -Object "BC application version: $BcApplicationVersion"
        Write-Host -Object "##vso[task.setvariable variable=BcApplicationVersion;]$BcApplicationVersion"
      env:
        BcArtifactSasToken: $(BcArtifactSasToken)
        BcArtifactVersion: $(BcArtifactVersion)
        BcArtifactType: $(BcArtifactType)
        BcArtifactStorageAccount: $(BcArtifactStorageAccount)
        BcArtifactCountry: $(BcArtifactCountry)
      displayName: Get BC application version
      
    - powershell: |
        Set-StrictMode -Version Latest
        
        # TODO: pull ManifestAppVersion, DockerImageVersion and maybe platform version outside because it duplicates with app copying to filestorage code
        [version]$CustomAppVersion = $env:CustomAppVersion
        [version]$ManifestAppVersion = `
          Get-Content -Path $env:MAINAPPFOLDER/app.json |
          ConvertFrom-Json |
          Select-Object -ExpandProperty version
        [version]$DockerImageVersion = $env:BcApplicationVersion
          
        Write-Host -Object "Custom app version:   $CustomAppVersion"
        Write-Host -Object "Docker image version: $DockerImageVersion"
        Write-Host -Object "Manifest app version: $ManifestAppVersion"
        
        [version]$SelectedAppVersion = `
          switch ($env:AppVersionSelection) {
            'manifest' {
              Write-Host -Object "Using app version from app manifest."
              [string]$ManifestAppVersion
            }
            'dockerImageMajorMinorAndManifestMajorMinor' {
              Write-Host -Object "Creating app version using Docker image major-minor version and app manifest major-minor version."
              '{0}.{1}.{2}.{3}' -f
                $DockerImageVersion.Major, $DockerImageVersion.Minor,
                $ManifestAppVersion.Major, $ManifestAppVersion.Minor
            }
            'dockerImageMajorMinorAndManifestBuildRevision' {
              Write-Host -Object "Creating app version using Docker image major-minor version and app manifest build-revision version."
              '{0}.{1}.{2}.{3}' -f
                $DockerImageVersion.Major, $DockerImageVersion.Minor,
                $ManifestAppVersion.Build, $ManifestAppVersion.Revision
            }
            'manual' {
              Write-Host -Object "Using custom app version."
              $CustomAppVersion
            }
          }
              
        Write-Host -Object "Selected app version: $SelectedAppVersion."
        Write-Host -Object "##vso[task.setvariable variable=AppVersion;]$SelectedAppVersion"
        
        if ($ManifestAppVersion.Major -ne $SelectedAppVersion.Major -or `
          $ManifestAppVersion.Minor -notin @(0, $SelectedAppVersion.Minor) -or `
          $ManifestAppVersion.Build -ne $SelectedAppVersion.Build -and `
          $ManifestAppVersion.Revision -ne $SelectedAppVersion.Revision)
        {
          if ($ManifestVersionMismatchAction -in @('warning', 'error')) {
            Write-Warning -Message "Manifest app version does not match selected app version."
          }
          if ($ManifestVersionMismatchAction -eq 'error') {
            exit(1)
          }
        }
        
        $CustomAppReleaseVersion = $env:CustomAppReleaseVersion
        Write-Host -Object "Custom app release version: $CustomAppReleaseVersion"
        $SelectedAppReleaseVersion = `
          switch ($env:AppReleaseVersionSelection) {
            'manifestMajorMinor' {
              Write-Host -Object "Creating app release version using app manifest major-minor version."
              '{0}.{1}' -f
                $ManifestAppVersion.Major, $ManifestAppVersion.Minor
            }
            'manifestBuildRevision' {
              Write-Host -Object "Creating app release version using app manifest build-revision version."
              '{0}.{1}' -f
                $ManifestAppVersion.Build, $ManifestAppVersion.Revision
            }
            'manual' {
              Write-Host -Object "Using custom app release version."
              $CustomAppReleaseVersion
            }
          }
        Write-Host -Object "Selected app release version: $SelectedAppReleaseVersion."
        Write-Host -Object "##vso[task.setvariable variable=AppReleaseVersion;]$SelectedAppReleaseVersion"
        
        Write-Host -Object "##vso[task.setvariable variable=ManifestAppVersion;]$ManifestAppVersion"
      env:
        AppVersionSelection: ${{ parameters.appVersionSelection }}
        CustomAppVersion: ${{ parameters.appVersion }}
        manifestVersionMismatchAction: ${{ parameters.manifestVersionMismatchAction }}
        AppReleaseVersionSelection: ${{ parameters.appReleaseVersionSelection }}
        CustomAppReleaseVersion: ${{ parameters.appReleaseVersion }}
        BcApplicationVersion: $(BcApplicationVersion)
      displayName: Get App Version
        
    - powershell: |
        Set-StrictMode -Version Latest
        
        $ManifestApp = `
          Get-Content -Path $env:MAINAPPFOLDER/app.json |
          ConvertFrom-Json
        $ManifestApp.Version = $env:AppVersion
        $ManifestApp |
          ConvertTo-Json |
           Set-Content -LiteralPath $env:MAINAPPFOLDER/app.json
        
        $Global:ContainerName = -join [char[]]([char]'a'..[char]'z' | Get-Random -Count 8)
        
        $NewBCContainer = { 
          param([hashtable]$Parameters)
          
          $Parameters['isolation'] = $env:DockerIsolation
          
          if ($env:RequireOmnivaConnectorAddIn -eq 'true') {
            Invoke-ScriptInBCContainer -containerName $Global:ContainerName -scriptblock { 
              Copy-Item -Path C:\Extension\MainApp\.netpackages\OmnivaConnector.dll `
                -Destination (Resolve-Path -Path 'C:\Program Files\Microsoft Dynamics NAV\*\Service\Add-ins\').ProviderPath 
            } 
          }  
          
          if ($env:RequireClosedXML -eq 'true') {
            New-Item -ItemType Directory -Path SofteraFiles
            Invoke-WebRequest -Uri https://www.nuget.org/api/v2/package/ClosedXML/0.88.0-beta1 -OutFile SofteraFiles\ClosedXML.zip
            Expand-Archive -Path SofteraFiles\ClosedXML.zip -DestinationPath SofteraFiles\ClosedXML
            Copy-Item -Path SofteraFiles\ClosedXML\lib\net452\*.dll -Destination (Resolve-Path -Path 'C:\Program Files\Microsoft Dynamics NAV\*\Service\Add-ins\').ProviderPath
            Invoke-WebRequest -Uri  https://www.nuget.org/api/v2/package/DocumentFormat.OpenXml/2.7.2 -OutFile SofteraFiles\DocumentFormat.zip
            Expand-Archive -Path SofteraFiles\DocumentFormat.zip -DestinationPath SofteraFiles\DocumentFormat
            Copy-Item -Path SofteraFiles\DocumentFormat\lib\net46\*.dll -Destination (Resolve-Path -Path 'C:\Program Files\Microsoft Dynamics NAV\*\Service\Add-ins\').ProviderPath
          }
          
          New-BcContainer @parameters
          Invoke-ScriptInBcContainer $parameters.ContainerName -argumentList $env:ALLanguageExtensionFileName -scriptblock {
              param($ALLanguageExtensionFileName)
              $progressPreference = 'SilentlyContinue'
              if ($ALLanguageExtensionFileName -ne '') {
                Remove-Item -Path 'C:\run\*.vsix'
              }
          }
          
          if ($env:ALLanguageExtensionFileName -ne '') {
            Copy-FileToBCContainer -containerName $Global:ContainerName -localPath $env:ALLanguageExtensionFileName -containerPath 'C:\run\ALLanguage.vsix'
          }
          
        }
        
        $CompileBcContainerApp = { 
          param([hashtable]$Parameters)
                    
          $Parameters['rulesetFile'] = $env:RulesetFileName
          
          Compile-AppInBcContainer @Parameters
        }
        
        $PublishBcContainerApp = { 
          param([hashtable]$Parameters)
                    
          Write-Host -Object "Publishing app $($Parameters['appFile'])" -Foreground Green
          
          Publish-BcContainerApp @Parameters
        }
        
        $InstallAppsFolders = `
          $env:LatestIntegrationCoreAppPath,
          $env:LatestSofteraBalticLoggingAppPath,
          $env:LatestCoreAppPath,
          $env:LatestHRAppPath,
          $env:LatestTimeScheduleAppPath,
          $env:LatestTimeEmployeeTimeAppPath,
          $env:LatestSalaryAppPath,
          $env:LatestLBCAlnaCoreAppPath
        $AppsFromDependencies = @(
          $InstallAppsFolders |
          Where-Object -FilterScript { $_ } |
          ForEach-Object -Process {
            $AppFiles = `
              Get-ChildItem -LiteralPath $_ -Filter '*.app' -Recurse |
              Select-Object -ExpandProperty FullName
            if ($AppFiles) {
              $AppFiles
            } else {
              Write-Host -Object "No app files found in folder $_."
              throw 'No app files found in folder.'
            }
          }
        )
               
        Write-Host -Object "Installed apps folders: $InstallAppsFolders"
        
        Run-AlPipeline `
            -pipelinename 'Build' `
            -containerName $Global:ContainerName `
            -artifact $env:ArtifactUrl `
            -baseFolder $env:BUILD_SOURCESDIRECTORY `
            -licenseFile $env:LicenseFile `
            -appFolders $env:MainAppFolder `
            -testFolders $env:TestAppFolder `
            -memoryLimit $env:DockerMemory `
            -codeSignCertPfxFile $env:CodeSignCertPfxFile `
            -codeSignCertPfxPassword (ConvertTo-SecureString -String $env:CodeSignCertPfxPassword -AsPlainText -Force) `
            -installApps $AppsFromDependencies `
            -azureDevOps `
            -enableCodeCop:($env:EnableCodeCop -eq 'true') `
            -enableAppSourceCop:($env:EnableAppSourceCop -eq 'true') `
            -enablePerTenantExtensionCop:($env:EnablePerTenantExtensionCop -eq 'true') `
            -enableUICop:($env:EnableUICop -eq 'true') `
            -NewBCContainer $NewBCContainer `
            -CompileAppInBcContainer $CompileBcContainerApp
            -PublishBcContainerApp $PublishBcContainerApp
            
         
        Write-Host -Object "##vso[task.setvariable variable=ContainerName;]$Global:ContainerName"
      env:
        ALLanguageExtensionFileName: ${{ parameters.alLanguageExtensionFileName }}
        RulesetFileName: ${{ parameters.rulesetFileName }}
        EnableCodeCop: ${{ parameters.enableCodeCop }}
        EnableAppSourceCop: ${{ parameters.enableAppSourceCop }}
        EnablePerTenantExtensionCop: ${{ parameters.enablePerTenantExtensionCop }}
        EnableUICop: ${{ parameters.enableUICop }}
        AppVersion: $(AppVersion)
        ArtifactUrl: $(ArtifactUrl)
        LicenseFile: $(DownloadBCLicense.SecureFilePath)
        CodeSignCertPfxFile: $(DownloadBCAppSigningCertificate.SecureFilePath)
        CodeSignCertPfxPassword: $(BCAppSigningCertificatePassword)
        MainAppFolder: $(MainAppFolder)
        TestAppFolder: $(TestAppFolder)
        DockerMemory: $(DockerMemory)
        DockerIsolation: ${{ parameters.dockerIsolation }}
        RequireOmnivaConnectorAddIn: ${{ parameters.eInvoice }}
        RequireClosedXML: ${{ parameters.S4LESSEE }}
        LatestIntegrationCoreAppPath: ${{ parameters.latestIntegrationCoreAppPath }}
        LatestSofteraBalticLoggingAppPath: ${{ parameters.latestSofteraBalticLoggingAppPath }}
        LatestCoreAppPath: ${{ parameters.latestCoreAppPath }}
        LatestHRAppPath: ${{ parameters.latestHRAppPath }}
        LatestTimeScheduleAppPath: ${{ parameters.latestTimeScheduleAppPath }}
        LatestTimeEmployeeTimeAppPath: ${{ parameters.latestTimeEmployeeTimeAppPath }}
        LatestSalaryAppPath: ${{ parameters.latestSalaryAppPath }}
        LatestLBCAlnaCoreAppPath: ${{ parameters.latestLBCAlnaCoreAppPath }}
      displayName: Run Pipeline

    - powershell: |    
        Write-Host -Object "IsReleasePRCommit: $env:IsReleasePRCommit"
        
        Set-StrictMode -Version Latest
        $DockerVersion = $env:BcApplicationVersion      
        $BranchName = `
            if ($env:IsPullRequest -eq 'false') {
                $env:Build_SourceBranchName
            } else {
                $env:System_PullRequest_TargetBranch -replace 'refs/heads/', ''
            }

        $CommonPath = "\\filestorage\Projects\DevOps\$env:OrganizationName\$env:System_TeamProject\$env:Build_Repository_Name\$env:AppReleaseVersion\$env:AppVersion\$BranchName-$DockerVersion"
        $TempPath = "$CommonPath-Temporary-$env:Build_BuildID"
        if ([System.IO.Directory]::Exists($TempPath)) {
            throw "TempPath ($TempPath) already exist"
        }

        New-Item -ItemType Directory -Path $TempPath -Force
        Copy-Item -Path * -Destination $TempPath -Recurse

        $OldPath = "$CommonPath-Old"
        if ([System.IO.Directory]::Exists($OldPath)) {
            Remove-Item -Path $OldPath -Recurse -Force
        }

        $Path = $CommonPath
        if ([System.IO.Directory]::Exists($Path)) {
            New-Item -ItemType Directory -Path $OldPath -Force
            Copy-Item -Path $Path\* -Destination $OldPath -Recurse
            Remove-Item -Path $Path -Recurse -Force
        }
        if (-not ([System.IO.Directory]::Exists($path))) {
            Copy-Item -Path $TempPath -Destination $Path -Recurse
            Remove-Item  -Path $TempPath -Recurse -Force
        }
      condition: eq(variables['IsReleasePRCommit'], 'True')
      env:
        IsReleasePRCommit: $(IsReleasePRCommit)
        AppReleaseVersion: $(AppReleaseVersion)
        BcApplicationVersion: $(BcApplicationVersion)
      displayName: Copy files to \\filestorage
        
#     - powershell: |
#         Remove-BcContainer -containerName $env:ContainerName; Flush-ContainerHelperCache -KeepDays 7
#       env:
#         ContainerName: $(ContainerName)
#       displayName: 'Cleanup'
#       condition: always()
